<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="If you're looking for concise and on-topic programming tutorials or cheat sheets and notes with examples, then you are in the right place! You will find courses about Python, web development, databases, and many others. This website is a personal portfolio and was created by one person.">
    <meta name="keywords" content="Programming, Coding, Python, Web Development, C++, HTML Tutorial, CSS Tutorial, Bootstrap Tutorial, Python Tutorial, C++ Tutorial, HTML, CSS, Bootstrap, Software Development, Algorithms, Data Structures, Programming Tutorials, Coding Tips, Code Examples, Programming Resources, Learn Python, Programming Beginner To Expert, Coding Community, Online Coding Courses, MS Access, Databases, OOP, Object Oriented Programming, IT, Computer Science, Data Science, AI, Django, TensorFlow, Java, Java Tutorial, Android, Android Studio, Kotlin, Electronics, Binary">
    <meta name="author" content="Tymoteusz Kołodziejczyk">
    <link href="font/css/all.min.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
    <link href="files/logo.png" rel="icon">
    <link href="files/logo.png" rel="apple-touch-icon">
    <link rel="stylesheet" href="css/fontello.css" type="text/css"/>
    <link rel="stylesheet" href="css/styles.css" type="text/css"/>
    <title>Threads, processes, and Async IO</title>
</head>

<body id="page-top">
    <div id="wrapper">
        <ul class="navbar-nav sidebar sidebar-dark accordion" id="accordionSidebar" style="background-color: #157267;">
            <a class="sidebar-brand d-flex align-items-center justify-content-center" href="index.html">
                    <img src="files/logo.png" alt="Logo" id="logo">
                <div class="sidebar-brand-text mx-3">CPUcademy</div>
            </a>
            
            <hr class="sidebar-divider my-0">
            <li class="nav-item active">
                <a class="nav-link" href="index.html">
                    <i class="icon-home"></i>
                    <span>Home</span></a>
            </li>
            <hr class="sidebar-divider" style="margin-bottom: 0px;">
    
            <li class="nav-item">
                <a class="nav-link collapsed" href="#" data-toggle="collapse" data-target="#collapseTwo"
                    aria-expanded="true" aria-controls="collapseTwo">
                    <i class="icon-th-list"></i>
                    <span>Tutorials</span>
                </a>
                <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionSidebar">
                    <div class="bg-white py-2 collapse-inner rounded">
                        <a class="collapse-item" href="python.html">Python</a>
                        <a class="collapse-item" href="java.html">Java &amp; Kotlin (Android)</a>
                        <a class="collapse-item" href="cplusplus.html">C++</a>
                        <a class="collapse-item" href="web.html">Basic web stack</a>
                        <a class="collapse-item" href="databases.html">Databases</a>
                        <a class="collapse-item" href="electronics.html">Electronics</a>
                        <a class="collapse-item" href="it-and-computer-basics.html">IT &amp; computer basics</a>
                    </div>
                </div>
            </li>
            <hr class="sidebar-divider">
            <div class="sidebar-heading">About me</div>
            
            <li class="nav-item">
                <a class="nav-link" href="cv.html">
                    <i class="icon-adult"></i>
                    <span>CV</span></a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="portfolio-projects.html">
                    <i class="icon-docs"></i>
                    <span>Portfolio projects</span></a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="services.html">
                    <i class="icon-services"></i>
                    <span>My services</span></a>
            </li>
            <hr class="sidebar-divider">
        </ul>

        <div id="content-wrapper" class="d-flex flex-column">
            <div id="content">
                <button id="sidebarToggleTop" class="btn btn-link d-md-none rounded-circle mr-3">
                    <i class="fa fa-bars" style="color: #157267;"></i>
                </button>

                <div class="container-fluid">
                    <div class="row">
                        <div class="col-lg-12 mb-4">
                            <div class="card shadow mb-4">
                                <div class="card-header py-3">
                                    <h5 class="m-0 font-weight-bold">Threads, processes, and Async IO</h5>
                                </div>
                                <div class="card-body">
                                    <p>Threads, processes, and Async IO (<code>async</code> and <code>await</code>) are all part of the asynchronous programming model. In this model, different functions can execute simultaneously or in a different order than usual. Threads are used for parallel tasks that share data with minimal CPU usage (e.g., handling multiple user requests in a web server). Processes are better suited for maximizing performance on CPU-intensive tasks (e.g., mathematical computations or image processing). Async IO is perfect for handling many tasks that involve much waiting (e.g., network requests or file operations).</p>

                                    <h2>Threads</h2>
                                    <p>Threads are a fundamental part of the Python concurrency model, allowing multiple tasks to run simultaneously within a single program. By utilizing threads, we can create more responsive and efficient applications, particularly in scenarios where tasks can be performed in parallel. Python provides built-in support for multithreading through the <code>threading</code> library.</p>

                                    <p>To create a thread, we instantiate a <code>Thread</code> object and select a function (its target), which contains the code to be executed by the thread. Once the thread is created, it can be started using the <code>start()</code> method.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
<span class="command">import</span> threading

<span class="function">def</span> count_to_10000():
    <span class="function">for</span> i <span class="function">in</span> <span class="command">range</span>(0, 10000):
        <span class="function">if</span> i <span class="sign">==</span> 9999:
            <span class="command">print</span>(<span class="text">"Task1: Counted to"</span>, i)

<span class="function">def</span> sum_to_10000():
    total <span class="sign">=</span> <span class="command">sum</span>(<span class="command">range</span>(0, 10000))
    <span class="command">print</span>(<span class="text">"\nTask2: Sum = "</span> <span class="sign">+</span> <span class="command">str</span>(total))

<span class="comment"># Creating threads</span>
task1 <span class="sign">=</span> threading.<span class="function">Thread</span>(<span class="command">target</span> <span class="sign">=</span> count_to_10000)
task2 <span class="sign">=</span> threading.<span class="function">Thread</span>(<span class="command">target</span> <span class="sign">=</span> sum_to_10000)

<span class="comment"># Starting threads</span>
task1.<span class="command">start</span>()
task2.<span class="command">start</span>()

<span class="comment"># Waiting for both threads to finish</span>
task1.<span class="command">join</span>()
task2.<span class="command">join</span>()

<span class="command">print</span>(<span class="text">"Both tasks completed."</span>)                                        
                                    </code></pre>

                                    <p>Threads can be synchronized to prevent concurrent access to shared resources, ensuring data consistency. Synchronization is applied using the <code>Lock</code> object. It ensures that only one thread accesses shared resources at a time.</p>

                                    <p>In the example below, the <code>Lock</code> object prevents multiple threads from modifying the <code>shared_resource</code> variable simultaneously, which could lead to inconsistencies due to race conditions. Without the lock, threads can interfere with each other while accessing the shared resource, causing the final result to be unpredictable. For example, two threads might read the same value of <code>shared_resource</code> , increment it, and write it back, effectively skipping one increment. This results in a final value that is less than expected. When a thread enters the block <code>with lock</code>, it first tries to acquire the lock. If another thread already holds the lock, the current thread will wait until the lock is released. Inside the locked block, the shared resource is modified. Once the thread finishes modifying <code>shared_resource</code>, the lock is automatically released.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
<span class="command">import</span> threading

shared_resource <span class="sign">=</span> 0
<span class="comment"># Creating a lock for synchronization</span>
lock <span class="sign">=</span> threading.<span class="function">Lock</span>()

<span class="function">def</span> increment():
    <span class="command">global</span> shared_resource
    <span class="function">for</span> i <span class="function">in</span> <span class="command">range</span>(1000):
        <span class="comment"># Acquiring the lock before printing</span>
        <span class="function">with</span> lock:
            shared_resource <span class="sign">+=</span> 1

<span class="comment"># Creating multiple threads</span>
threads <span class="sign">=</span> []
<span class="function">for</span> i <span class="function">in</span> <span class="command">range</span>(10):
    thread <span class="sign">=</span> threading.<span class="function">Thread</span>(<span class="command">target</span> <span class="sign">=</span> increment)
    threads.<span class="command">append</span>(thread)
    thread.<span class="command">start</span>()

<span class="comment"># Waiting for all threads to finish</span>
<span class="function">for</span> thread <span class="function">in</span> threads:
    thread.<span class="command">join</span>()

<span class="command">print</span>(<span class="text">"Final value of shared_resource:"</span>, shared_resource)
                                    </code></pre>

                                    <h2>Processes, GIL (Global Interpreter Lock)</h2>

                                    <p>The Global Interpreter Lock (GIL) is a mechanism used in CPython (the most widely used Python interpreter) to ensure that only one thread executes Python bytecode at a time in a single process. We can't "use" it directly because it is an internal mechanism in the CPython interpreter that runs automatically. If our program is CPU-bound and we want to take full advantage of multiple CPU cores, using the <code>multiprocessing</code> module (library) can bypass the GIL. This module spawns separate processes, each with its own interpreter and GIL, allowing true parallelism.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
<span class="command">import</span> multiprocessing

<span class="comment"># A simple CPU-bound task</span>
<span class="function">def</span> cpu_bound_task():
    total <span class="sign">=</span> 0
    <span class="function">for</span> i <span class="function">in</span> <span class="command">range</span>(10 <span class="sign">**</span> 7):
        total <span class="sign">+=</span> i
    <span class="function">return</span> total

processes <span class="sign">=</span> []
<span class="function">for</span> x <span class="function">in</span> <span class="command">range</span>(4):
    process <span class="sign">=</span> multiprocessing.<span class="function">Process</span>(target <span class="sign">=</span> cpu_bound_task)
    processes.<span class="command">append</span>(process)
    process.<span class="command">start</span>()

<span class="comment"># Waiting for all processes to finish</span>
<span class="function">for</span> process <span class="function">in</span> processes:
    process.<span class="command">join</span>()

<span class="command">print</span>(<span class="text">"Completed all processes."</span>)
                                    </code></pre>

                                    <h2>Async IO</h2>

                                    <p>The event loop manages the execution of asynchronous I/O tasks. When it begins, it processes any scheduled coroutines or tasks. If a coroutine reaches an await expression (such as when waiting for I/O operations), it relinquishes control to the event loop, enabling other tasks to run while the current one is on hold. The event loop continues to operate until all tasks have been completed.</p>

                                    <p>A coroutine object represents an asynchronous operation but does not run until scheduled. A task is a scheduled coroutine run by the event loop. It represents an active operation that can be awaited or managed during execution. A coroutine object (typically the main coroutine) should be passed as an argument to the <code>asyncio.run()</code> function to start the event loop.</p>

                                    <p>The <code>async</code> keyword is used to define a function as asynchronous, meaning it can perform non-blocking operations. Inside an asynchronous function, the <code>await</code> keyword is used to pause execution until a coroutine completes, allowing other actions to run concurrently. When <code>await</code> is called, the function relinquishes control to the event loop, which can then execute other coroutines while waiting. This enables efficient handling of I/O-bound tasks without blocking the entire program. Only after we <code>await</code> a coroutine, it actually starts executing.</p>

                                    <p>A coroutine starts executing as soon as it is called, but it doesn't actually run to completion until it is awaited. When we call a coroutine, it returns a coroutine object, that has not yet executed its body. That coroutine object has to be then awaited for us to see results.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
import asyncio

async def fetch():
    print("Fetching...")
    await asyncio.sleep(2) # simulating work
    print("Data fetched.")
    return "data"

async def main():
    print("Start of the main coroutine.")
    coroutine = fetch()
    print("End of the main coroutine.")
    result = await coroutine
    print("Result:", result)

asyncio.run(main())
                                    </code></pre>

                                    <h4>Tasks</h4>

                                    <p>As I said earlier, a task is a scheduled coroutine run by the event loop. <code>asyncio.create_task()</code> is used to schedule a coroutine for concurrent execution. It converts a coroutine into a <code>Task</code> object, which is managed by the event loop. Tasks allow multiple coroutines to run concurrently, and they execute independently while the program continues with other operations. In the example below, using Async IO will shorten the execution time from 6 to 3 seconds because the tasks execute simultaneously.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
import asyncio

async def fetch(ID, sleep):
    print(f"Coroutine {ID} has started.")
    await asyncio.sleep(sleep)
    return f"Data from coroutine {ID}"

async def main():
    # Method 1
    task1 = asyncio.create_task(fetch(1, 1))
    task2 = asyncio.create_task(fetch(2, 2))
    task3 = asyncio.create_task(fetch(3, 3))

    result1 = await task1
    result2 = await task2
    result3 = await task3

    print(result1, result2, result3)

    # Method 2
    # This method is worse for error handling because if one coroutine fails, it won't cancel out the rest.
    results = await asyncio.gather(fetch(1, 1), fetch(2, 2), fetch(3, 3))
    for result in results:
        print(result)

asyncio.run(main())
                                    </code></pre>

                                    <p>In the example below, we can see a <code>TaskGroup</code> usage example. It provides a cleaner way to handle tasks.</p>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
import asyncio

async def fetch(ID, sleep):
    print(f"Coroutine {ID} starting to fetch data.")
    await asyncio.sleep(sleep)
    return {"ID": ID, "data": f"Sample data from coroutine {ID}"}

async def main():
    tasks = []
    async with asyncio.TaskGroup() as tg:
        for i, sleep in enumerate([2, 1, 3], start = 1):
            print(i)
            task = tg.create_task(fetch(i, sleep))
            tasks.append(task)
    # The code will get to this point only after completing all the tasks stated above.
    results = [task.result() for task in tasks]

    for result in results:
        print(f"Received result: {result}")

asyncio.run(main())                                        
                                    </code></pre>

                                    <h4>Synchronization</h4>

                                    <h5>Lock</h5>

                                    <pre class="wp-block-csstricks-code-block code-example" data-line="" style="color: #EFEEEE;"><code markup="tt">
import asyncio

shared_resource = 0
lock = asyncio.Lock()

async def increment():
    global shared_resource
    for i in range(1000):
        async with lock:
            print("Resource before modification:", shared_resource)
            shared_resource += 1
            await asyncio.sleep(1)
            print("Resource after modification:", shared_resource)

async def main():
    results = await asyncio.gather(*(increment() for i in range(5)))

asyncio.run(main())
                                    </code></pre>

                                    <h5>Semaphore</h5>

                                    <h5>Event</h5>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <footer class="sticky-footer bg-white">
                <div class="container my-auto">
                    <div class="copyright text-center my-auto">
                        <span>Copyright &copy; CPUcademy All Rights Reserved | <a href="license-and-sources.html" class="link">License &amp; Sources</a></span>
                    </div>
                </div>
            </footer>
        </div>
    </div>
    <script src="configs/jquery/jquery.min.js"></script>
    <script src="configs/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="configs/script.js"></script>
</body>
</html>